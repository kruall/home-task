# HOME TASK

## Сборка и запуск

```(bash)
./build.sh
./build/bin/client_server
```

## Принцип работы в общих словах

Клетка массива задается двумя значениями: индентификатор клетки и хранимое значение.
При удалении значения в запросе указывается только индентиикатор клетки.
При вставке значения указывается индентификатор клетки после которой планируем встать.
Индентификатор начинается с 1, поэтому при указании 0, вставка произойдет в начало массива.

Индентификатор идет по порядку, но по хорошему надо реализовать пул свобоодных диапазонов индентификаторов и уже из него выдвать значения.

Состояние массива хранится в виде сохраненного стейта + история изменений + номер итерации.
При каждом изменении номер итерации увеличивается на 1.

Каждый запрос это сама команда и последний известный номер итерации.

Каждый ответ, это история изменений после номера итерации в запросе + номер итерации.

На сервере так же хранится список клиентов с последним подтвержденным номером итерации полученным клиентом.
Инвалидация подтвержденных номеров по времени или по размеру истории не реализована.

Сервер при получении запроса:
1. сдвигает подтвержденным номером итерации полученным клиентом,
2. добавляет к ответу историю о которой не знает клиент и текущий номер итерации
3. отправляет ответ
4. применяет хвост истории(изменения которые известны всем клиентам) к стейту массива

Первенство запросов определяется тем кого первее начал обрабатывать сервер, а не по времени создания.

Клиент при получении запроса:
1. применяет полученную часть истории к своему стейту массива
2. cохраняет номер итерации

Таким образом по сети передается только дифф изменений.

## Стейт массива сервера

В качестве двух основных контейнеров используются двусвязный список и хеш-таблица.

Двусвязный список позволяет быстро производить вставку.
Хеш-таблица  позволяет быстро находить клетки по их индентификатору.

Так же хранится история изменений поддерживаемая начиная с самой старой итерации которую знают клиенты.
При получении запросов от клиентов, самая старая известная итерация может сдвинуться и история порежется.

### Самая старая итерация

Поддержка самой старой итерации работает через приоритетную очередь и хеш-таблицы
Для каждого клиента мы знаем известную ему итерации, и кладем ее в очередь.
После каждой итерации проверяем не изменилась ли самая старая известная итерация.
1. Если итерация текущего клиента не самая старая, то обновляем информацию только в хеш-таблице.
2. Если самая старая, то убираем ее из очереди и кладем с правильным значением.
3. Для каждого следующего топа сверяем его итерацию с итерацией в хеш-таблице, при несовпадении обновляем значение в очереди.
4. Продолжаем пока топ не станет совпадать со значение в хеш-таблице.

Так как операция 3 выполнится суммарно не больше чем операция 1, то амортизированная асимптотика O(log(<количество клиентов>)).

Для малого количества клиентов стоит поменять структуру на массив, так как проход по нему будет быстрее всей машинерии сверху.

### Жизнь клекти

Из-за того, что не все клиенты знают о удалении клетки, то на сервер может прийти запрос на вставку после удаленной клетки. Из-за этого нам надо хранить информацию о ней и не убирать из структуры, пока история о ее удалении не порежется. В крайних случая она может жить еще дольше.

Клетка представляет из себя ноду двухсвязаного списка, поэтому знает своих соседей справа и слева.
Так же из-за поддерживания в живом состоянии удаленных клеток, нам может потребоваться механизм быстрого поиска живой клетки слева, для этого клетка так же хранит указатель на живого по ее мнению соседа. Подробнее об этом механизме будет позже.

Жизнь клетки поддерживается счетчиком ссылок. Ссылкой считается указатель на правого соседа, указатель на живого соседа, операция с этой клеткой.

Как только у клетки остается только одна ссылка (указатель на текущую клетку у левого соседа), то клетка отправляется на удаление.

Для каждой клетки всегда существуют оба соседа. Так как список зациклен на корне, то есть корень самый первый и самый последний элемент.

Из-за того что корню нет необходимости обновлять ближайшую живую клетку слева, то при простой реализации хвост списка может долго не подчищаться.  
Для этого при отрезании истории о удалении требуется проверить, является ли удаляемая вершина ближайшей живой для правого соседа, в случае если да, то дать правому соседу ссылку на ближайшего живогоо по мнению удаляемой клетки. После этого ссылка как на ближайшего живого уйдет, и хвост списка спокойно подчиститься.

### Ближайший живойсосед

#### Поиск 

Поиск ближайшего живого соседа происходит путем прохождения по указателям живого соседа, до тех пор пока не встретим живого. Попутно обновляя эту информацию у всех клеток которые встретили на пути.

Данная структура напоминает систему непересекающихся множест, из-за чего асимптотика поиска будет не хуже обраной функции аккермана. Но из-за линейности, она превращается в амоортизированную O(1).

#### Вставка элемента после удаленного

Но из-за распредленности истории, может произойти вставка после удаленного элемента. В особо неудачном случае информация о ближайшем живом соседе уже обновилась у ближайших клеток.

В таком случае придется поправить указатель на новь добавленную клетку у соседей справа.

Делать это мы будем до тех пор пока не найдем вершину, которая указывает как на живую на левого соседа.
Очевидно что в худшем случае мы будем идти до тех пор пока не встретим живую клетку. Таким образом O(<подряд удаленные элементы>)

##### При активных пользователях

Теперь попробуем оценить на сколько это проблемно при всех активных пользователях.
Очевидно что вставка после удаленной клетки может быть произведена, когда не знаешь об удаленнии этой клетки.
Таким образом окно для удаления ограничивается окном между запросами от клиента.
При одинаковом постоянном рейте запросов, то количество новых удаленных клеток будет не больше количества клиентов.

Теперь поговорим о количестве старых удаленных клеток.
В каких случаях удаленная клетка продолжает жить:
1. На нее ссылается операция с клеткой
2. На нее ссылается больше одной клетки как на живую

Разберем случаи:
1. При всех активных клиенах, история будет соразмерно количеству клиентов.
2. В таком случае на эту клетку было применен поиск ближайшего живого. А значит какое-то количество соседей справа указывают на нее. Из этого следует, что соседи справа либо находятся в истории либо живые. Следует это из того, что если сосед справа удаленный и не в истории, то его не должно быть в списке, так как на него ссылается только текущий элемент. Правый сосед правого соседа ссылается как на живую на текущую клетку  вместо правого соседа.

Таким образом операция имеет асимптотику O(количество клиентов) при всех активных клиентах.

##### При отвалившемся пользователе

Рассмотрим случай, отвалившегося клиента, которого нельзя выкинуть. Таким история изменений выростет на порядки больше чем количество клиентов. Но при этом активная история о которой не знаю клиенты кроме отвалившегося все еще будет соразмерна количеству активных клиентов. И так как клиенты забудут о клетках которые были удалены очен давно, то операции не будут затрагивать удаленный отрезок.

Первая удаленная клетка в отрезке давно удаленных клеток будет указывать на на живую клетку, либо клетка справа  будет указывать на нее как на живую, что остановит алгоритм при вставке клетки после удаленной.

Но при повторном подключении операция вставки клетки от отвалившегося элемента может быть долгой.
Пути обхода  не реализованы, но можно объединять давние удаленные клетки, чтобы им не обновлять ближайшего живого.

### Отправка изменений клиентам

На каждый запрос отправляется пачка изменений которые произошли на сервере.

1. Сначала идут изменения значений, для неудаленных клеток
2. После идут вставки элементов, если в истории сервера клетка после которой происходит вставка была удалена, то сервер ищет ближайшей живую клетку справа и подменяет на нее
3. Удаление клеток

Таким образом стейт на клиенте обновляется до корректного серверного.
Так как поиск ближайшей живой клетки это O(1) а остальные операции тривиальны, то отправка любого изменения занимает O(1).

И следовательно асимптотика отправки измениний будет не хуже О(размер неизвестной истории)

### Операции

Так как основные операции не делают значительных изменений, только вставка в список или изменение внутренного стейта клеток, то асимптотика для них O(1)

### Выгрузка состояния сервера

Ответ собирается путем прохода по двусвязному списку.

Асимптотика  O(количество живых клеток + количество удлаенных клеток)

При длинной истории операция может занимать знаачительное время проходя большое количество удаленных клеток.
Чтобы этого избежать можно добавить объединение удаленных клеток как было предложено во вставке после удаленной клетки.
Либо добавить вырезку из середины истории удалений.

### История

В данном случае не усмотрено, но отвалившиеся клиенты могут доставить большие проблемы серверу. Поэтому требуется реализовать выкидывание по таймауту или по длине истории.

### Персистентость 

Можно сохранять стейт и истории. После превышении размера истории, можно повторять операцию.

Запись операций истории не затратна, но комбинация из <старый стейт> + <история> позволяет быстро восстановить стейт.

## Стейт массива клиента

Стейт массива для клиента состоит из следующих контейнеров:
1. Сбалансирвованное дерево поиска, где вместо ключа индекс элемента (для примера используеся декартово дерево, но лучше использовать другое дерево) 
2. Хеш-таблица {индентификатор клетки, итератор на клетку в дереве}

Дерев поиска позволяет относительно быстро получать доступ к рандомному элементe, а хеш-таблица получать элемент по его ключу.

Генерация запросов:
O(log<количествоо элементов в масссиве>)

Применение запросов:
O(log<количествоо элементов в масссиве>)

Применение стейта:
O(log<количествоо элементов в масссиве> * <количествоо элементов в масссиве>)
В идеале можно реализовать через стек построение декартова дерева в O(<количествоо элементов в масссиве>)


## Результаты

Из минус, большое потребление RAM; В прогоне потребляет примерно 27GB на сервер и всех клиентов.
При теоретическом минимуме 4 * 10^7 * 21 = 840MB
Выходит из того, что ноды используемых контейнеров занимают гораздо больше места чем само значение

Без учета первой выгрузки стейта
SBPS - SentBytesPerSecond
RBPS - ReceivedBytesPerSecond
```
Id# 1 SentBytes# 28.36kB ReceivedBytes# 153.45kB
 SBPS# 284.70B/s RBPS# 1.54kB/s
 Iterations# 484 IterationsPerSecond# 4.86 WorkTime# 99.61s
Id# 2 SentBytes# 27.77kB ReceivedBytes# 153.14kB
 SBPS# 280.14B/s RBPS# 1.54kB/s
 Iterations# 484 IterationsPerSecond# 4.88 WorkTime# 99.12s
Id# 3 SentBytes# 27.99kB ReceivedBytes# 152.94kB
 SBPS# 285.23B/s RBPS# 1.56kB/s
 Iterations# 484 IterationsPerSecond# 4.93 WorkTime# 98.14s
Id# 4 SentBytes# 28.20kB ReceivedBytes# 153.07kB
 SBPS# 283.55B/s RBPS# 1.54kB/s
 Iterations# 484 IterationsPerSecond# 4.87 WorkTime# 99.45s
Id# 5 SentBytes# 27.75kB ReceivedBytes# 153.21kB
 SBPS# 279.53B/s RBPS# 1.54kB/s
 Iterations# 484 IterationsPerSecond# 4.88 WorkTime# 99.28s
Id# 6 SentBytes# 27.74kB ReceivedBytes# 152.95kB
 SBPS# 282.15B/s RBPS# 1.56kB/s
 Iterations# 484 IterationsPerSecond# 4.92 WorkTime# 98.30s
Id# 7 SentBytes# 28.03kB ReceivedBytes# 153.11kB
 SBPS# 283.74B/s RBPS# 1.55kB/s
 Iterations# 484 IterationsPerSecond# 4.90 WorkTime# 98.79s
Id# 8 SentBytes# 28.15kB ReceivedBytes# 153.26kB
 SBPS# 284.51B/s RBPS# 1.55kB/s
 Iterations# 484 IterationsPerSecond# 4.89 WorkTime# 98.95s
Id# 9 SentBytes# 27.87kB ReceivedBytes# 153.10kB
 SBPS# 282.59B/s RBPS# 1.55kB/s
 Iterations# 484 IterationsPerSecond# 4.91 WorkTime# 98.63s
Id# 10 SentBytes# 28.04kB ReceivedBytes# 153.31kB
 SBPS# 284.77B/s RBPS# 1.56kB/s
 Iterations# 484 IterationsPerSecond# 4.92 WorkTime# 98.46s
Id# 11 SentBytes# 28.15kB ReceivedBytes# 153.26kB
 SBPS# 287.37B/s RBPS# 1.56kB/s
 Iterations# 484 IterationsPerSecond# 4.94 WorkTime# 97.96s
Id# 12 SentBytes# 28.02kB ReceivedBytes# 153.34kB
 SBPS# 286.53B/s RBPS# 1.57kB/s
 Iterations# 484 IterationsPerSecond# 4.95 WorkTime# 97.80s
Id# 13 SentBytes# 28.30kB ReceivedBytes# 153.32kB
 SBPS# 292.38B/s RBPS# 1.58kB/s
 Iterations# 484 IterationsPerSecond# 5.00 WorkTime# 96.80s
Id# 14 SentBytes# 28.08kB ReceivedBytes# 153.12kB
 SBPS# 287.58B/s RBPS# 1.57kB/s
 Iterations# 484 IterationsPerSecond# 4.96 WorkTime# 97.64s
Id# 15 SentBytes# 28.21kB ReceivedBytes# 153.30kB
 SBPS# 289.39B/s RBPS# 1.57kB/s
 Iterations# 484 IterationsPerSecond# 4.97 WorkTime# 97.48s
Id# 16 SentBytes# 28.20kB ReceivedBytes# 153.16kB
 SBPS# 289.80B/s RBPS# 1.57kB/s
 Iterations# 484 IterationsPerSecond# 4.97 WorkTime# 97.31s
Id# 17 SentBytes# 28.20kB ReceivedBytes# 153.15kB
 SBPS# 290.33B/s RBPS# 1.58kB/s
 Iterations# 484 IterationsPerSecond# 4.98 WorkTime# 97.13s
Id# 18 SentBytes# 27.98kB ReceivedBytes# 153.15kB
 SBPS# 288.50B/s RBPS# 1.58kB/s
 Iterations# 484 IterationsPerSecond# 4.99 WorkTime# 96.97s
Id# 19 SentBytes# 28.25kB ReceivedBytes# 153.46kB
 SBPS# 292.02B/s RBPS# 1.59kB/s
 Iterations# 484 IterationsPerSecond# 5.00 WorkTime# 96.73s
Id# 20 SentBytes# 28.23kB ReceivedBytes# 153.26kB
 SBPS# 292.46B/s RBPS# 1.59kB/s
 Iterations# 483 IterationsPerSecond# 5.00 WorkTime# 96.53s
```

## Тесты

Как-то без тестов получилось

P.S. Проверка проводилась путем проверки стейтов клиентов и сервера.
